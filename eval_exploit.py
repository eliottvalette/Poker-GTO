# eval_exploit.py
# ============================================================
# Évaluation d'exploitabilité de la politique moyenne CFR+
# ============================================================
# 
# Pour chaque rôle i, on calcule l'EV vs Best Response (BR) :
# - i joue une best-response myope *par simulation* (rollouts)
# - les 2 autres suivent la politique moyenne
# 
# On reporte l'EV (en BB) moyenne pour chaque rôle.
# Plus l'EV est proche de 0, moins la politique est exploitable.
# ============================================================

from __future__ import annotations
from typing import List, Tuple, Dict
from tqdm import trange
import statistics as stats
import time
import os

from policy import AveragePolicy

# =========================
# Configuration
# =========================
ROLLOUTS_PER_ACTION = 64   # simulations par action candidate
EPISODES = 200             # mains pour la moyenne
DEBUG_EVAL = True

# =========================
# Utilitaires d'environnement
# =========================
def fresh_env():
    """Crée un nouvel environnement de jeu"""
    from poker_game_expresso import PokerGameExpresso, GameInit
    
    init = GameInit()
    init.stacks_init = [100, 100, 100]  # SB, BB, BTN
    init.total_bets_init = [0, 0, 0]
    init.current_bets_init = [0, 0, 0]
    init.active_init = [True, True, True]
    init.has_acted_init = [False, False, False]
    init.main_pot = 0
    init.phase = "PREFLOP"
    init.community_cards = []
    
    game = PokerGameExpresso(init)
    game.deal_small_and_big_blind()
    return game

# =========================
# Logique d'évaluation
# =========================
def terminal_play(env, pol: AveragePolicy) -> List[float]:
    """Joue jusqu'à la fin avec la politique moyenne pour tous les joueurs"""
    while env.current_phase != "SHOWDOWN":
        # Récupérer le joueur courant
        current_player = env.players[env.current_role]
        
        # Obtenir les actions légales
        legal_actions = env.update_available_actions(
            current_player,
            env.current_maximum_bet,
            env.number_raise_this_game_phase,
            env.main_pot,
            env.current_phase
        )
        
        if not legal_actions:
            # Aucune action légale, vérifier la progression de phase
            env.check_phase_completion()
            continue
        
        # Choisir l'action selon la politique
        action = pol.act(env)
        
        # Appliquer l'action
        env.process_action(current_player, action)
    
    # Calculer les gains finaux
    final_stacks = {p.name: p.stack for p in env.players}
    initial_stacks = {p.name: 100.0 for p in env.players}  # Stack initial fixe
    
    gains = []
    for i, player in enumerate(env.players):
        gain = final_stacks[player.name] - initial_stacks[player.name]
        gains.append(gain)
    
    return gains

def br_step_value(env, pol: AveragePolicy, br_player: int, action: str) -> float:
    """Estime la valeur d'une action par rollouts"""
    # Cloner l'environnement
    from copy import deepcopy
    nxt = deepcopy(env)
    
    # Appliquer l'action
    current_player = nxt.players[nxt.current_role]
    nxt.process_action(current_player, action)
    
    # Terminer avec la politique moyenne
    util = terminal_play(nxt, pol)
    return util[br_player]

def choose_br_action(env, pol: AveragePolicy, br_player: int) -> str:
    """Choisit la meilleure action par simulation (Best Response)"""
    # Récupérer le joueur courant
    current_player = env.players[env.current_role]
    
    # Obtenir les actions légales
    legal_actions = env.update_available_actions(
        current_player,
        env.current_maximum_bet,
        env.number_raise_this_game_phase,
        env.main_pot,
        env.current_phase
    )
    
    if not legal_actions:
        return "CHECK"  # fallback
    
    # Estimer la valeur de chaque action par rollouts
    values = []
    for a in legal_actions:
        acc = 0.0
        for _ in range(ROLLOUTS_PER_ACTION):
            acc += br_step_value(env, pol, br_player, a)
        values.append(acc / ROLLOUTS_PER_ACTION)
    
    # Choisir l'action avec la meilleure valeur
    best_i = max(range(len(legal_actions)), key=lambda i: values[i])
    return legal_actions[best_i]

def eval_vs_br(pol: AveragePolicy, br_player: int) -> float:
    """Évalue l'exploitabilité d'un rôle spécifique vs Best Response"""
    gains = []
    
    # Barre de progression pour les épisodes
    with trange(EPISODES, desc=f"BR approx (player {br_player})", leave=False) as pbar:
        for episode in pbar:
            # Créer un nouvel environnement
            env = fresh_env()
            
            # Jouer la partie entière
            while env.current_phase != "SHOWDOWN":
                cur_role = env.current_role
                
                if cur_role == br_player:
                    # Joueur BR : choisir action par argmax simulé
                    a = choose_br_action(env, pol, br_player)
                else:
                    # Autres joueurs : suivre la politique moyenne
                    a = pol.act(env)
                
                # Appliquer l'action
                current_player = env.players[cur_role]
                env.process_action(current_player, a)
            
            # Calculer les gains finaux
            util = terminal_play(env, pol)
            gains.append(util[br_player])
            
            # Mise à jour de la barre
            pbar.set_postfix({'EV': f"{util[br_player]:+.3f}"})
    
    return stats.mean(gains) if gains else 0.0

# =========================
# Fonction principale
# =========================
def main():
    """Fonction principale d'évaluation d'exploitabilité"""
    print(f"\n{'='*80}")
    print(f"ÉVALUATION D'EXPLOITABILITÉ CFR+")
    print(f"{'='*80}")
    print(f"Configuration:")
    print(f"  Rollouts par action: {ROLLOUTS_PER_ACTION}")
    print(f"  Épisodes par rôle: {EPISODES}")
    print(f"  Total simulations: {ROLLOUTS_PER_ACTION * EPISODES * 3}")
    print(f"{'='*80}\n")
    
    # Charger la politique moyenne
    policy_path = "policy/avg_policy.json.gz"
    if not os.path.exists(policy_path):
        print(f"[ERREUR] Fichier de politique non trouvé: {policy_path}")
        print("Veuillez d'abord entraîner le solveur CFR+")
        return
    
    print(f"[LOAD] Chargement de la politique: {policy_path}")
    pol = AveragePolicy.load(policy_path, seed=777)
    
    # Évaluation pour chaque rôle
    start_time = time.time()
    results = []
    
    print(f"\nDémarrage de l'évaluation...")
    for i in range(3):
        role_name = ["SB", "BB", "BTN"][i]
        print(f"\n--- Évaluation rôle {i} ({role_name}) ---")
        
        ev = eval_vs_br(pol, i)
        results.append(ev)
        
        print(f"[EVAL] EV vs BR (player {i} as BR): {ev:+.3f} BB")
    
    # Résumé final
    total_time = time.time() - start_time
    
    print(f"\n{'='*80}")
    print(f"RÉSUMÉ DE L'ÉVALUATION")
    print(f"{'='*80}")
    print(f"Temps total: {total_time:.2f}s")
    print(f"Simulations totales: {ROLLOUTS_PER_ACTION * EPISODES * 3}")
    print(f"\nExploitabilité par rôle:")
    
    for i, ev in enumerate(results):
        role_name = ["SB", "BB", "BTN"][i]
        exploitability = "FAIBLE" if abs(ev) < 0.1 else "ÉLEVÉE" if abs(ev) > 0.5 else "MODÉRÉE"
        print(f"  {role_name} (role {i}): {ev:+.3f} BB [{exploitability}]")
    
    # Moyenne d'exploitabilité
    avg_exploit = stats.mean([abs(ev) for ev in results])
    print(f"\nExploitabilité moyenne: {avg_exploit:.3f} BB")
    
    if avg_exploit < 0.1:
        print("✅ Politique très peu exploitable (proche de l'équilibre)")
    elif avg_exploit < 0.3:
        print("⚠️  Politique modérément exploitable")
    else:
        print("❌ Politique fortement exploitable")
    
    print(f"{'='*80}")
    
    # Sauvegarder les résultats
    results_data = {
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        "config": {
            "rollouts_per_action": ROLLOUTS_PER_ACTION,
            "episodes": EPISODES
        },
        "results": {
            "SB": results[0],
            "BB": results[1], 
            "BTN": results[2]
        },
        "summary": {
            "avg_exploitability": avg_exploit,
            "total_time": total_time
        }
    }
    
    # Créer le dossier results s'il n'existe pas
    os.makedirs('results', exist_ok=True)
    
    import json
    results_path = "results/exploitability_eval.json"
    with open(results_path, "w", encoding="utf-8") as f:
        json.dump(results_data, f, indent=2, ensure_ascii=False)
    
    print(f"\nRésultats sauvegardés dans: {results_path}")

if __name__ == "__main__":
    main()
